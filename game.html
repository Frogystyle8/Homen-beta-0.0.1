<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Game</title>
<style>
  :root{--accent:#4cc9f0}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071018,#020305);font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#e6eef6;overflow:hidden}
  #root{display:flex;align-items:center;justify-content:center;height:100%;width:100%;position:relative}
  canvas#game{width:100%;height:auto;max-width:1280px;border-radius:12px;box-shadow:0 18px 60px rgba(0,0,0,.7);background:#071018;display:block}
  .hud{position:fixed;left:12px;right:12px;top:12px;height:48px;display:flex;align-items:center;justify-content:space-between;padding:8px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));z-index:1200}
  .muted{color:#9fb6c6;font-size:13px}
  .status{font-weight:700}
  .waitingBar{height:12px;background:#0f1720;border-radius:999px;overflow:hidden;width:260px}
  .waitingFill{height:100%;background:linear-gradient(90deg,var(--accent),#6b9cff);width:0%}
  .minimap{position:fixed;right:12px;bottom:12px;width:220px;height:132px;border-radius:10px;background:linear-gradient(180deg,#041018,#071018);padding:8px;box-shadow:0 12px 40px rgba(0,0,0,.6);z-index:1150}
  .minimap canvas{width:100%;height:100%;display:block;border-radius:6px}
  .action-btn{position:fixed;right:18px;bottom:18px;width:84px;height:84px;border-radius:50%;background:linear-gradient(180deg,var(--accent),#2a9fb8);color:#021018;font-weight:800;font-size:16px;display:flex;align-items:center;justify-content:center;cursor:pointer;z-index:1180;border:2px solid rgba(255,255,255,0.06)}
  .overlayBlack{position:fixed;inset:0;background:#000;display:none;align-items:center;justify-content:center;color:#fff;font-size:28px;z-index:2000;flex-direction:column;gap:12px}
  .overlayBlack .bigTimer{font-size:72px;font-weight:900}
  .endScreen{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;z-index:2100}
  .endCard{background:#fff;color:#021018;padding:20px;border-radius:12px;min-width:320px;text-align:center}
</style>
</head>
<body>
  <div id="root">
    <canvas id="game" width="1280" height="720" aria-label="Game canvas"></canvas>
  </div>

  <div class="hud" role="status" aria-live="polite">
    <div style="display:flex;align-items:center;gap:12px">
      <div class="muted">Room</div>
      <div id="roomCode" class="status">LOCAL</div>
    </div>
    <div style="display:flex;align-items:center;gap:12px">
      <div class="muted">Waiting</div>
      <div class="waitingBar"><div id="waitingFill" class="waitingFill"></div></div>
      <div id="readyCount" class="muted">0/0</div>
      <div id="phaseText" class="muted">idle</div>
    </div>
    <div style="display:flex;align-items:center;gap:12px">
      <div class="muted">Freeze</div>
      <div id="freezeTimer" class="status">00</div>
      <div class="muted">Game</div>
      <div id="mainTimer" class="status">10:00</div>
    </div>
  </div>

  <div class="minimap" id="minimap"><canvas id="miniCanvas" width="200" height="120"></canvas></div>
  <button id="actionBtn" class="action-btn">Action</button>

  <div id="blackOverlay" class="overlayBlack" aria-hidden="true">
    <div style="font-size:28px;font-weight:800">Catch them boy</div>
    <div class="bigTimer" id="overlayBigTimer">30</div>
  </div>

  <div id="endScreen" class="endScreen" role="dialog" aria-hidden="true">
    <div class="endCard">
      <h2 id="endTitle">Game Over</h2>
      <div style="margin-top:12px">Winner: <strong id="winnerName">—</strong></div>
      <div style="margin-top:16px"><button id="homeBtn" class="action-btn" style="width:auto;height:auto;padding:8px 12px;border-radius:8px">Home</button></div>
    </div>
  </div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
import { getDatabase, ref, get, set, update, onValue } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyD8Vz9WCsGwvs8a3hm0smPFysM0lMnF2uY",
  authDomain: "data-c6b63.firebaseapp.com",
  databaseURL: "https://data-c6b63-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "data-c6b63",
  storageBucket: "data-c6b63.firebasedestorage.app",
  messagingSenderId: "473217478100",
  appId: "1:473217478100:web:e9508960991fa41",
  measurementId: "G-8P4JRVVCTR"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getDatabase(app);

/* UI refs */
const roomCodeEl = document.getElementById('roomCode');
const waitingFill = document.getElementById('waitingFill');
const readyCountEl = document.getElementById('readyCount');
const phaseText = document.getElementById('phaseText');
const freezeTimerEl = document.getElementById('freezeTimer');
const mainTimerEl = document.getElementById('mainTimer');
const overlay = document.getElementById('blackOverlay');
const overlayBigTimer = document.getElementById('overlayBigTimer');
const actionBtn = document.getElementById('actionBtn');
const endScreen = document.getElementById('endScreen');
const winnerNameEl = document.getElementById('winnerName');
const homeBtn = document.getElementById('homeBtn');

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const miniCanvas = document.getElementById('miniCanvas');
const miniCtx = miniCanvas.getContext('2d');

const INTERNAL_W = 1280, INTERNAL_H = 720;
const MAP_W = 3600, MAP_H = 2100;
const PLAYER_RADIUS = 20;

/* local state */
let local = { uid: null, gameName: null };
let localPlayer = { uid: 'me', x: MAP_W/2, y: MAP_H/2, caught:false, transformed:false };
let members = {}; // DB snapshot of members
let currentRoom = null;

/* timers & phases */
let phase = 'waiting';
let countdownStart = 0;
let freezeUntil = 0;
let gameEndAt = 0;
const COUNTDOWN3 = 3, FREEZE_SECONDS = 30, MAIN_SECONDS = 10*60;
let tickHandle = null;

/* helpers */
function getRoomFromQuery(){
  const p = new URLSearchParams(window.location.search);
  return (p.get('room') || '').toUpperCase() || null;
}
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function fmtTime(s){ if (s<0) s=0; const m=Math.floor(s/60).toString().padStart(2,'0'); const sec=Math.floor(s%60).toString().padStart(2,'0'); return `${m}:${sec}`; }

/* join room and listen */
let membersUnsub = null, roomUnsub = null;
async function joinRoomAndListen(roomCode){
  if (!roomCode) return;
  currentRoom = roomCode;
  roomCodeEl.textContent = roomCode;

  const membersRef = ref(db, `rooms/${roomCode}/members`);
  const roomRef = ref(db, `rooms/${roomCode}`);

  if (membersUnsub) membersUnsub();
  membersUnsub = onValue(membersRef, snap => {
    members = snap.exists() ? snap.val() : {};
    updateWaitingUIFromMembers(members);
    // update localPlayer if DB has our entry
    if (local.uid && members[local.uid]) {
      const m = members[local.uid];
      localPlayer.x = m.x ?? localPlayer.x;
      localPlayer.y = m.y ?? localPlayer.y;
      localPlayer.caught = !!m.caught;
      localPlayer.transformed = !!m.transformed;
    }
  });

  if (roomUnsub) roomUnsub();
  roomUnsub = onValue(roomRef, snap => {
    const room = snap.exists() ? snap.val() : {};
    if (room.phase && room.phase !== phase) {
      phase = room.phase;
      if (phase === 'countdown3') { countdownStart = room.countdownStart || Date.now(); waitingFill.parentElement.style.display='none'; startTick(); }
      if (phase === 'freeze30') { freezeUntil = room.freezeUntil || Date.now()+FREEZE_SECONDS*1000; }
      if (phase === 'running') { gameEndAt = room.gameEndAt || Date.now()+MAIN_SECONDS*1000; }
    }
    // store catcher for minimap logic
    members.room = members.room || {};
    members.room.catcher = room.catcher || members.room.catcher;
  });
}

/* update HUD from members snapshot */
function updateWaitingUIFromMembers(membersObj){
  const arr = Object.values(membersObj || {}).filter(m => m && m.uid);
  const total = arr.length || 0;
  const ready = arr.filter(m => m.ready).length || 0;
  readyCountEl.textContent = `${ready}/${total}`;
  waitingFill.style.width = total ? `${Math.round((ready/total)*100)}%` : '0%';
}

/* defensive auto-join after auth */
async function autoJoinRoomFlow(){
  const code = getRoomFromQuery();
  if (!code) {
    // no room param -> go back to lobby
    window.location.href = 'custom.html';
    return;
  }
  await joinRoomAndListen(code);
}

/* auth and start */
onAuthStateChanged(auth, async user => {
  if (!user) {
    // if not signed in, redirect to index (or sign in anonymously)
    window.location.href = 'index.html';
    return;
  }
  local.uid = user.uid;
  local.gameName = user.email ? user.email.split('@')[0] : user.uid.slice(0,6);
  // ensure we have a member entry in DB (so others see us)
  const code = getRoomFromQuery();
  if (code) {
    await set(ref(db, `rooms/${code}/members/${local.uid}`), {
      uid: local.uid,
      gameName: local.gameName,
      x: localPlayer.x, y: localPlayer.y,
      ready: true,
      caught: false,
      transformed: false,
      isBot: false
    });
  }
  await autoJoinRoomFlow();
});

/* startTick: sync with DB room phase/timers */
function startTick(){
  if (tickHandle) clearInterval(tickHandle);
  tickHandle = setInterval(async () => {
    if (!currentRoom) return;
    const roomSnap = await get(ref(db, `rooms/${currentRoom}`));
    const data = roomSnap.exists() ? roomSnap.val() : {};
    const dbPhase = data.phase || 'waiting';
    if (dbPhase === 'countdown3'){
      const startAt = data.countdownStart || Date.now();
      const elapsed = Math.floor((Date.now() - startAt)/1000);
      const remain = Math.max(0, COUNTDOWN3 - elapsed);
      phaseText.textContent = `Starting in ${remain}s`;
      if (remain <= 0){
        // pick catcher and set freeze in DB (owner or server should do this; we attempt a safe update)
        const membersSnap = await get(ref(db, `rooms/${currentRoom}/members`));
        const mem = membersSnap.exists() ? membersSnap.val() : {};
        const uids = Object.keys(mem || {});
        const pick = uids.length ? uids[Math.floor(Math.random()*uids.length)] : null;
        if (pick) {
          await update(ref(db, `rooms/${currentRoom}`), { phase: 'freeze30', freezeUntil: Date.now() + FREEZE_SECONDS*1000, catcher: pick });
        } else {
          await update(ref(db, `rooms/${currentRoom}`), { phase: 'freeze30', freezeUntil: Date.now() + FREEZE_SECONDS*1000 });
        }
      }
    } else if (dbPhase === 'freeze30'){
      const remain = Math.max(0, Math.ceil(((data.freezeUntil || Date.now()) - Date.now())/1000));
      freezeTimerEl.textContent = String(remain);
      overlayBigTimer.textContent = String(remain);
      // show overlay only if local is catcher
      if (data.catcher === local.uid) overlay.style.display = 'flex';
      else overlay.style.display = 'none';
      if (remain <= 0){
        await update(ref(db, `rooms/${currentRoom}`), { phase: 'running', gameEndAt: Date.now() + MAIN_SECONDS*1000 });
      }
    } else if (dbPhase === 'running'){
      const remain = Math.max(0, Math.ceil(((data.gameEndAt || Date.now()) - Date.now())/1000));
      mainTimerEl.textContent = fmtTime(remain);
      if (remain <= 0 && !data.finished){
        // compute winner (simple: pick random uncaught)
        const memSnap = await get(ref(db, `rooms/${currentRoom}/members`));
        const mem = memSnap.exists() ? memSnap.val() : {};
        const uncaught = Object.keys(mem || {}).filter(k => mem[k] && !mem[k].caught);
        const winner = uncaught.length ? uncaught[Math.floor(Math.random()*uncaught.length)] : data.catcher;
        await update(ref(db, `rooms/${currentRoom}`), { finished: true, winnerUid: winner, finishedAt: Date.now() });
      }
    } else if (dbPhase === 'finished'){
      const winnerUid = data.winnerUid;
      const memSnap = await get(ref(db, `rooms/${currentRoom}/members/${winnerUid}`));
      const winnerName = memSnap.exists() ? (memSnap.val().gameName || winnerUid) : '—';
      winnerNameEl.textContent = winnerName;
      endScreen.style.display = 'flex';
      clearInterval(tickHandle);
    }
  }, 400);
}

/* simple rendering: draw members from DB */
function render(){
  ctx.fillStyle = '#071018'; ctx.fillRect(0,0,INTERNAL_W,INTERNAL_H);
  // grid
  ctx.strokeStyle = 'rgba(255,255,255,0.02)'; ctx.lineWidth = 1;
  const tile = 128;
  for (let x = - (0 % tile); x < INTERNAL_W; x += tile){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,INTERNAL_H); ctx.stroke(); }
  for (let y = - (0 % tile); y < INTERNAL_H; y += tile){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(INTERNAL_W,y); ctx.stroke(); }

  // draw members
  const list = Object.entries(members || {}).filter(([k]) => k !== 'room').map(([uid,m]) => ({ uid, ...m }));
  for (const p of list){
    const sx = (p.x || MAP_W/2) % INTERNAL_W;
    const sy = (p.y || MAP_H/2) % INTERNAL_H;
    ctx.beginPath();
    ctx.fillStyle = p.caught ? '#666' : (p.uid === (members.room && members.room.catcher) ? '#ffd166' : '#4cc9f0');
    ctx.arc(sx, sy, PLAYER_RADIUS, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff'; ctx.font = '12px system-ui,Arial'; ctx.textAlign = 'center';
    ctx.fillText(p.gameName || p.uid.slice(0,6), sx, sy - PLAYER_RADIUS - 8);
  }

  // minimap
  drawMiniMap();
}

/* minimap: show players unless local is seeker and main timer > 60 */
function drawMiniMap(){
  const w = miniCanvas.width, h = miniCanvas.height;
  miniCtx.clearRect(0,0,w,h);
  miniCtx.fillStyle = '#041018'; miniCtx.fillRect(0,0,w,h);
  const sx = w / MAP_W, sy = h / MAP_H;
  // objects omitted for brevity
  const mainRemain = gameEndAt ? Math.max(0, Math.ceil((gameEndAt - Date.now())/1000)) : MAIN_SECONDS;
  const seekerIsLocal = members.room && members.room.catcher === local.uid;
  const showPlayers = !seekerIsLocal || mainRemain <= 60;
  for (const [uid,m] of Object.entries(members || {})){
    if (uid === 'room') continue;
    if (!showPlayers && uid !== local.uid) continue;
    miniCtx.beginPath();
    miniCtx.fillStyle = m.caught ? '#666' : (m.uid === (members.room && members.room.catcher) ? '#ffd166' : '#4cc9f0');
    miniCtx.arc((m.x||0) * sx, (m.y||0) * sy, 4, 0, Math.PI*2); miniCtx.fill();
  }
}

/* main loop */
let last = performance.now();
function loop(now){
  const dt = Math.min(0.05, (now - last)/1000);
  last = now;
  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* action button: transform/hide (simple local toggle + DB write) */
actionBtn.addEventListener('click', async () => {
  if (!currentRoom || !local.uid) return;
  localPlayer.transformed = !localPlayer.transformed;
  await update(ref(db, `rooms/${currentRoom}/members/${local.uid}`), {
    transformed: !!localPlayer.transformed,
    transformTarget: localPlayer.transformed ? { id: 'manual', type: 'manual' } : null
  });
});

/* home button */
homeBtn.addEventListener('click', ()=> window.location.href = 'custom.html');

</script>
</body>
</html>
