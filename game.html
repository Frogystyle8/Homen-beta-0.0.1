<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Tag — Multiplayer (Action button, bot, auto-join)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#071018; --accent:#4cc9f0; --accent-2:#ffd166; --danger:#ff6b6b;
      --panel:rgba(255,255,255,0.04);
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071018,#020305);font-family:Inter,system-ui,Segoe UI,Roboto,Arial;color:#e6eef6;overflow:hidden}
    #root{display:flex;align-items:center;justify-content:center;height:100%;width:100%;position:relative}
    canvas#game{width:100%;height:auto;max-width:1280px;border-radius:12px;box-shadow:0 18px 60px rgba(0,0,0,.7);background:#071018;display:block;touch-action:none}
    .hud{position:fixed;left:12px;right:12px;top:12px;height:48px;display:flex;align-items:center;justify-content:space-between;gap:12px;padding:8px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));z-index:1200}
    .muted{color:#9fb6c6;font-size:13px}
    .status{font-weight:700}
    .waitingBar{height:12px;background:#0f1720;border-radius:999px;overflow:hidden;width:260px}
    .waitingFill{height:100%;background:linear-gradient(90deg,var(--accent),#6b9cff);width:0%}
    .minimap{position:fixed;right:12px;bottom:12px;width:220px;height:132px;border-radius:10px;background:linear-gradient(180deg,#041018,#071018);padding:8px;box-shadow:0 12px 40px rgba(0,0,0,.6);z-index:1150}
    .minimap canvas{width:100%;height:100%;display:block;border-radius:6px}
    .touch-controls{position:fixed;left:12px;bottom:12px;width:220px;height:220px;pointer-events:none;z-index:1160}
    .joystick{position:absolute;left:0;bottom:0;width:100%;height:100%;pointer-events:auto;touch-action:none}
    .stick-base{position:absolute;left:8px;bottom:8px;width:160px;height:160px;border-radius:50%;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));display:flex;align-items:center;justify-content:center;box-shadow:inset 0 8px 30px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.03);touch-action:none}
    .stick-knob{width:48px;height:48px;border-radius:50%;background:linear-gradient(180deg,#ffffff12,#00000022);box-shadow:0 10px 30px rgba(0,0,0,0.6);transform:translate(0,0);pointer-events:none}
    .overlayBlack{position:fixed;inset:0;background:#000;display:none;align-items:center;justify-content:center;color:#fff;font-size:28px;z-index:2000;flex-direction:column;gap:12px}
    .overlayBlack .bigTimer{font-size:72px;font-weight:900}
    .endScreen{position:fixed;inset:0;background:rgba(0,0,0,0.6);display:none;align-items:center;justify-content:center;z-index:2100}
    .endCard{background:#fff;color:#021018;padding:20px;border-radius:12px;min-width:320px;text-align:center}
    .btn{padding:8px 12px;border-radius:8px;border:none;background:var(--accent);color:#021018;font-weight:700;cursor:pointer}
    .small{font-size:13px;color:#9fb6c6}
    .playerChip{background:var(--panel);padding:6px 10px;border-radius:999px;color:#e6eef6;font-weight:700;margin:4px}
    .caught{opacity:.45;text-decoration:line-through}
    .action-btn{
      position:fixed;
      right:18px;
      bottom:18px;
      width:84px;
      height:84px;
      border-radius:50%;
      background:linear-gradient(180deg,var(--accent),#2a9fb8);
      color:#021018;
      font-weight:800;
      font-size:16px;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      z-index:1180;
      box-shadow:0 12px 30px rgba(0,0,0,0.6);
      border:2px solid rgba(255,255,255,0.06);
      touch-action:manipulation;
    }
    .hidden{display:none !important}
    @media (max-width:720px){
      .minimap{width:160px;height:96px}
      .stick-base{width:120px;height:120px}
      .action-btn{right:12px;bottom:12px;width:64px;height:64px;font-size:14px}
    }
  </style>
</head>
<body>
  <div id="root">
    <canvas id="game" width="1280" height="720" aria-label="Polished Tag game"></canvas>
  </div>

  <div class="hud" role="status" aria-live="polite">
    <div style="display:flex;align-items:center;gap:12px">
      <div class="muted">Room</div>
      <div id="roomCode" class="status">LOCAL</div>
      <div style="width:12px"></div>
      <div class="muted">You</div>
      <div id="youName" class="status">Player</div>
    </div>

    <div style="display:flex;align-items:center;gap:12px">
      <div class="muted">Waiting</div>
      <div class="waitingBar" id="waitingBar"><div id="waitingFill" class="waitingFill"></div></div>
      <div id="readyCount" class="small">0/0</div>
      <div style="width:12px"></div>
      <div id="phaseText" class="small" title="Click to ready">idle</div>
    </div>

    <div style="display:flex;align-items:center;gap:12px">
      <div class="muted">Freeze</div>
      <div id="freezeTimer" class="status">00</div>
      <div style="width:12px"></div>
      <div class="muted">Game</div>
      <div id="mainTimer" class="status">10:00</div>
    </div>
  </div>

  <div class="minimap" id="minimap">
    <canvas id="miniCanvas" width="200" height="120"></canvas>
  </div>

  <div class="touch-controls" id="touchControls">
    <div class="joystick" id="joystick">
      <div class="stick-base" id="stickBase">
        <div class="stick-knob" id="stickKnob"></div>
      </div>
    </div>
  </div>

  <button id="actionBtn" class="action-btn" aria-label="Action">Action</button>

  <div id="blackOverlay" class="overlayBlack" aria-hidden="true">
    <div style="font-size:28px;font-weight:800">Catch them boy</div>
    <div class="bigTimer" id="overlayBigTimer">30</div>
  </div>

  <div id="endScreen" class="endScreen" role="dialog" aria-hidden="true">
    <div class="endCard">
      <h2 id="endTitle">Game Over</h2>
      <div style="margin-top:12px">Winner: <strong id="winnerName">—</strong></div>
      <div style="margin-top:16px">
        <button id="homeBtn" class="btn">Home</button>
      </div>
    </div>
  </div>

  <script type="module">
    // Firebase imports (same as other pages)
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";
    import { getDatabase, ref, get, set, update, onValue, runTransaction } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

    // Firebase config (use your project's config)
    const firebaseConfig = {
      apiKey: "AIzaSyD8Vz9WCsGwvs8a3hm0smPFysM0lMnF2uY",
      authDomain: "data-c6b63.firebaseapp.com",
      databaseURL: "https://data-c6b63-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "data-c6b63",
      storageBucket: "data-c6b63.firebasedestorage.app",
      messagingSenderId: "473217478100",
      appId: "1:473217478100:web:e9508960991a17dfa1fa41",
      measurementId: "G-8P4JRVVCTR"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getDatabase(app);

    /* -------------------------
       Canvas & world (polished)
       ------------------------- */
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: false });
    const miniCanvas = document.getElementById('miniCanvas');
    const miniCtx = miniCanvas.getContext('2d');
    const INTERNAL_W = 1280, INTERNAL_H = 720;
    const MAP_W = 3600, MAP_H = 2100;
    const PLAYER_RADIUS = 20;

    function fitCanvas(){
      const winW = window.innerWidth, winH = window.innerHeight;
      const scale = Math.min(winW * 0.98 / INTERNAL_W, winH * 0.82 / INTERNAL_H);
      canvas.style.width = Math.round(INTERNAL_W * scale) + 'px';
      canvas.style.height = Math.round(INTERNAL_H * scale) + 'px';
    }
    window.addEventListener('resize', fitCanvas);
    fitCanvas();

    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function rand(min,max){ return min + Math.random()*(max-min); }
    function fmtTime(s){ if (s<0) s=0; const m=Math.floor(s/60).toString().padStart(2,'0'); const sec=Math.floor(s%60).toString().padStart(2,'0'); return `${m}:${sec}`; }
    function shade(hex, percent){
      const f = hex.slice(1);
      const r = parseInt(f.substring(0,2),16);
      const g = parseInt(f.substring(2,4),16);
      const b = parseInt(f.substring(4,6),16);
      const t = percent < 0 ? 0 : 255;
      const p = Math.abs(percent);
      const R = Math.round((t - r) * p) + r;
      const G = Math.round((t - g) * p) + g;
      const B = Math.round((t - b) * p) + b;
      return `rgb(${R},${G},${B})`;
    }

    /* -------------------------
       World: objects, pickups, walls
       ------------------------- */
    const objects = [];
    const walls = [
      {x:300,y:160,w:1200,h:28},
      {x:1600,y:420,w:28,h:1100},
      {x:700,y:1400,w:1400,h:28},
      {x:220,y:760,w:28,h:900},
      {x:2600,y:200,w:28,h:900},
      {x:2800,y:1200,w:800,h:28}
    ];
    const objectPalette = [
      {type:'crate', base:'#8B5A2B'},
      {type:'plant', base:'#7FD1B9'},
      {type:'barrel', base:'#FFB86B'},
      {type:'lamp', base:'#FFD166'},
      {type:'sofa', base:'#9E7BFF'},
      {type:'bench', base:'#6B7280'}
    ];
    function placeObjects(){
      for(let i=0;i<110;i++){
        const t = objectPalette[Math.floor(Math.random()*objectPalette.length)];
        objects.push({
          id: i,
          type: t.type,
          x: rand(80, MAP_W-80),
          y: rand(80, MAP_H-80),
          w: Math.round(rand(36, 140)),
          h: Math.round(rand(24, 90)),
          color: t.base,
          angle: rand(-0.25,0.25),
          detail: Math.random()
        });
      }
    }
    placeObjects();

    const pickups = [];
    const PICKUP_TYPES = [
      {id:'speed', color:'#6be4ff', ttl:12},
      {id:'invis', color:'#b28cff', ttl:8},
      {id:'decoy', color:'#ffd166', ttl:10}
    ];
    function spawnPickup(x,y){
      const p = PICKUP_TYPES[Math.floor(Math.random()*PICKUP_TYPES.length)];
      pickups.push({
        id: Date.now()+Math.random(),
        type: p.id,
        color: p.color,
        x, y,
        radius: 12,
        life: 60
      });
    }
    for(let i=0;i<18;i++) spawnPickup(rand(120, MAP_W-120), rand(120, MAP_H-120));

    const particles = [];
    function spawnParticles(x,y,color,count=12){
      for(let i=0;i<count;i++){
        particles.push({
          x,y,
          vx: rand(-220,220),
          vy: rand(-220,220),
          life: rand(0.4,1.0),
          size: rand(2,6),
          color
        });
      }
    }

    /* -------------------------
       Local state and DB state
       ------------------------- */
    const local = { uid: null, gameName: null };
    let roomCode = null;
    let roomRef = null;
    let membersRef = null;
    let roomUnsub = null;
    let membersUnsub = null;
    const cam = { x:0, y:0, w:INTERNAL_W, h:INTERNAL_H };

    // local player object (keeps in sync with DB)
    let localPlayer = {
      uid: 'me-local',
      gameName: 'You',
      x: MAP_W/2,
      y: MAP_H/2,
      vx:0, vy:0,
      speed: 220,
      caught:false,
      ready:false,
      transformed:false,
      transformTarget: null,
      freezeBlocked:false,
      invis:false,
      speedUntil:0,
      invisUntil:0,
      decoyUntil:0,
      isBot:false
    };

    // cached members from DB
    let members = {}; // uid -> data

    /* -------------------------
       Input & joystick
       ------------------------- */
    const keys = {};
    window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

    const stickBase = document.getElementById('stickBase');
    const stickKnob = document.getElementById('stickKnob');
    let touchId = null;
    let joy = {x:0,y:0,active:false};

    function getLocalPos(el, clientX, clientY){
      const r = el.getBoundingClientRect();
      return { x: clientX - r.left, y: clientY - r.top, w: r.width, h: r.height };
    }
    function startJoy(e){
      if (e.cancelable) e.preventDefault();
      const touch = e.changedTouches ? e.changedTouches[0] : e;
      touchId = touch.identifier ?? 'mouse';
      joy.active = true;
      updateJoy(touch);
      window.addEventListener('touchmove', onWindowTouchMove, { passive:false });
      window.addEventListener('mousemove', onMouseMove, { passive:false });
    }
    function updateJoy(touch){
      const p = getLocalPos(stickBase, touch.clientX, touch.clientY);
      const cx = p.w/2, cy = p.h/2;
      const dx = p.x - cx, dy = p.y - cy;
      const max = Math.min(p.w,p.h)/2 - 10;
      const d = Math.hypot(dx,dy);
      const nx = d ? dx/d : 0, ny = d ? dy/d : 0;
      const mag = Math.min(d, max) / max;
      joy.x = nx * mag; joy.y = ny * mag;
      stickKnob.style.transform = `translate(${joy.x * max}px, ${joy.y * max}px)`;
    }
    function endJoy(e){
      if (e && e.cancelable) e.preventDefault();
      joy.active = false; touchId = null; joy.x = 0; joy.y = 0;
      stickKnob.style.transform = `translate(0px, 0px)`;
      window.removeEventListener('touchmove', onWindowTouchMove, { passive:false });
      window.removeEventListener('mousemove', onMouseMove, { passive:false });
    }
    function onWindowTouchMove(e){
      if (!joy.active) return;
      for (const t of e.changedTouches) {
        if (touchId === 'mouse' || t.identifier === touchId) {
          if (e.cancelable) e.preventDefault();
          updateJoy(t);
          break;
        }
      }
    }
    function onMouseMove(e){ if (!joy.active) return; if (e.cancelable) e.preventDefault(); updateJoy(e); }

    stickBase.addEventListener('touchstart', startJoy, { passive:false });
    stickBase.addEventListener('touchmove', (e)=>{ for (const t of e.changedTouches) if (touchId===null||t.identifier===touchId){ updateJoy(t); break } }, { passive:false });
    stickBase.addEventListener('touchend', (e)=>{ endJoy(e); }, { passive:false });
    stickBase.addEventListener('touchcancel', (e)=>{ endJoy(e); }, { passive:false });
    stickBase.addEventListener('mousedown', (e)=>{ startJoy(e); });
    window.addEventListener('mouseup', (e)=>{ if (joy.active) endJoy(e); });

    /* -------------------------
       Action button (transform / throw)
       ------------------------- */
    const actionBtn = document.getElementById('actionBtn');
    actionBtn.addEventListener('click', () => {
      // If local is transformed -> throw (not implemented full physics here)
      if (localPlayer.transformed) {
        // simple throw: spawn a particle and stun nearby seeker (server should handle)
        spawnParticles(localPlayer.x + 30, localPlayer.y, '#ffd166', 12);
        localPlayer.transformed = false;
        localPlayer.transformTarget = null;
        writeLocalPlayer(); // sync to DB
      } else {
        // attempt transform: find nearest object
        let nearest = null, nd = Infinity;
        for (const o of objects){
          const d = Math.hypot(localPlayer.x - o.x, localPlayer.y - o.y);
          if (d < 80 && d < nd){ nearest = o; nd = d; }
        }
        if (nearest){
          localPlayer.transformed = true;
          localPlayer.transformTarget = { id: nearest.id, type: nearest.type };
          spawnParticles(localPlayer.x, localPlayer.y, '#9b7bff', 12);
          writeLocalPlayer();
        }
      }
    });

    /* -------------------------
       Firebase: join room, sync members, add bot if needed
       ------------------------- */
    function getRoomFromQuery() {
      const params = new URLSearchParams(window.location.search);
      return (params.get('room') || '').toUpperCase() || null;
    }

    async function findRoomForUser(uid) {
      try {
        const roomsSnap = await get(ref(db, 'rooms'));
        if (!roomsSnap.exists()) return null;
        const rooms = roomsSnap.val();
        for (const code of Object.keys(rooms)) {
          const memberSnap = await get(ref(db, `rooms/${code}/members/${uid}`));
          if (memberSnap.exists()) return code;
        }
      } catch (e) { console.error(e); }
      return null;
    }

    async function joinRoomAndSync(code) {
      roomCode = code;
      document.getElementById('roomCode').textContent = roomCode;
      roomRef = ref(db, `rooms/${roomCode}`);
      membersRef = ref(db, `rooms/${roomCode}/members`);

      // ensure local user has a DB member entry
      const uid = local.uid;
      const memberRef = ref(db, `rooms/${roomCode}/members/${uid}`);
      await set(memberRef, {
        uid,
        gameName: local.gameName || uid.slice(0,6),
        x: localPlayer.x,
        y: localPlayer.y,
        ready: true,
        caught: false,
        transformed: false,
        isBot: false
      });

      // listen for members
      if (membersUnsub) membersUnsub();
      membersUnsub = onValue(membersRef, snap => {
        members = snap.exists() ? snap.val() : {};
        // if only one human present and no bot, create a bot member in DB
        ensureBotInRoom();
        // update local state if DB has our entry (keeps authoritative)
        if (members[uid]) {
          const m = members[uid];
          localPlayer.x = m.x ?? localPlayer.x;
          localPlayer.y = m.y ?? localPlayer.y;
          localPlayer.caught = !!m.caught;
          localPlayer.transformed = !!m.transformed;
          localPlayer.transformTarget = m.transformTarget || localPlayer.transformTarget;
        }
        updateWaitingUI();
      });

      // listen for room metadata (catcher, phase)
      if (roomUnsub) roomUnsub();
      roomUnsub = onValue(roomRef, snap => {
        const data = snap.exists() ? snap.val() : null;
        if (!data) return;
        // handle phase transitions from DB if custom.html started the game
        if (data.phase && data.phase !== phase) {
          phase = data.phase;
          if (phase === 'countdown3') {
            countdownStart = data.countdownStart || Date.now();
            waitingBar.style.display = 'none';
            startTick(); // ensure tick runs locally too
          } else if (phase === 'freeze30') {
            freezeUntil = data.freezeUntil || Date.now() + FREEZE_SECONDS*1000;
            if (data.catcher === local.uid) {
              blackOverlay.style.display = 'flex';
            }
          } else if (phase === 'running') {
            gameEndAt = data.gameEndAt || Date.now() + MAIN_SECONDS*1000;
            blackOverlay.style.display = 'none';
          }
        }
      });

      // start local bot controller if we created a bot entry
      startLocalBotController();
    }

    async function ensureBotInRoom() {
      if (!members) return;
      // count humans and bots
      const humanCount = Object.values(members).filter(m => !m.isBot).length;
      const botExists = Object.values(members).some(m => m.isBot);
      // if only one human and no bot, create a bot member
      if (humanCount <= 1 && !botExists) {
        const botId = `bot-${Date.now()}`;
        await set(ref(db, `rooms/${roomCode}/members/${botId}`), {
          uid: botId,
          gameName: 'Bot',
          x: localPlayer.x + 200,
          y: localPlayer.y + 120,
          ready: true,
          caught: false,
          transformed: false,
          isBot: true
        });
      }
    }

    // write local player's DB entry (throttled)
    let lastWrite = 0;
    async function writeLocalPlayer() {
      if (!roomCode || !local.uid) return;
      const now = Date.now();
      if (now - lastWrite < 200) return;
      lastWrite = now;
      try {
        await update(ref(db, `rooms/${roomCode}/members/${local.uid}`), {
          x: localPlayer.x,
          y: localPlayer.y,
          caught: !!localPlayer.caught,
          transformed: !!localPlayer.transformed,
          transformTarget: localPlayer.transformTarget || null,
          ready: true
        });
      } catch (e) { console.error(e); }
    }

    /* -------------------------
       Bot controller (runs locally on this client)
       - moves the DB bot entry around
       - learns to use transform (hide) by moving near objects and setting transformed flag in DB
       ------------------------- */
    let botControllerHandle = null;
    function startLocalBotController() {
      // only one controller per client
      if (botControllerHandle) return;
      botControllerHandle = setInterval(async () => {
        if (!roomCode) return;
        try {
          const membersSnap = await get(membersRef);
          if (!membersSnap.exists()) return;
          const mem = membersSnap.val();
          // find a bot entry that this client should control: pick first bot without "controlledBy"
          let botEntryId = null;
          for (const [id, m] of Object.entries(mem)) {
            if (m.isBot && (!m.controlledBy || m.controlledBy === local.uid)) {
              botEntryId = id;
              break;
            }
          }
          if (!botEntryId) return;
          // claim control (lightweight)
          await update(ref(db, `rooms/${roomCode}/members/${botEntryId}`), { controlledBy: local.uid });

          // read current bot state
          const botSnap = await get(ref(db, `rooms/${roomCode}/members/${botEntryId}`));
          if (!botSnap.exists()) return;
          const bot = botSnap.val();

          // simple AI: if not transformed, move toward nearest object and transform; if transformed, move randomly
          if (!bot.caught) {
            // if not transformed, try to find nearby object
            if (!bot.transformed) {
              // find nearest object
              let nearest = null, nd = Infinity;
              for (const o of objects) {
                const d = Math.hypot((o.x || 0) - (bot.x || 0), (o.y || 0) - (bot.y || 0));
                if (d < nd) { nd = d; nearest = o; }
              }
              if (nearest && nd > 40) {
                // move toward object
                const dx = nearest.x - bot.x, dy = nearest.y - bot.y; const d = Math.hypot(dx,dy)||1;
                const step = 120 + Math.random()*80;
                const nx = bot.x + (dx/d) * step;
                const ny = bot.y + (dy/d) * step;
                await update(ref(db, `rooms/${roomCode}/members/${botEntryId}`), { x: nx, y: ny });
              } else if (nearest && nd <= 80) {
                // transform (hide)
                await update(ref(db, `rooms/${roomCode}/members/${botEntryId}`), {
                  transformed: true,
                  transformTarget: { id: nearest.id, type: nearest.type }
                });
                // stay hidden for a bit
                await new Promise(r => setTimeout(r, 1200 + Math.random()*1200));
                // sometimes untransform after a while
                if (Math.random() < 0.5) {
                  await update(ref(db, `rooms/${roomCode}/members/${botEntryId}`), { transformed: false, transformTarget: null });
                }
              } else {
                // wander
                await update(ref(db, `rooms/${roomCode}/members/${botEntryId}`), {
                  x: bot.x + rand(-120,120),
                  y: bot.y + rand(-120,120)
                });
              }
            } else {
              // if transformed, occasionally untransform and move
              if (Math.random() < 0.25) {
                await update(ref(db, `rooms/${roomCode}/members/${botEntryId}`), { transformed: false, transformTarget: null });
              } else {
                await update(ref(db, `rooms/${roomCode}/members/${botEntryId}`), {
                  x: bot.x + rand(-40,40),
                  y: bot.y + rand(-40,40)
                });
              }
            }
          }
        } catch (e) {
          console.error('bot controller error', e);
        }
      }, 900);
    }

    /* -------------------------
       Game loop & rendering (client-side)
       ------------------------- */
    const particlesLocal = [];
    function spawnParticlesLocal(x,y,color,count=12){
      for(let i=0;i<count;i++){
        particlesLocal.push({ x,y, vx: rand(-220,220), vy: rand(-220,220), life: rand(0.4,1.0), size: rand(2,6), color });
      }
    }

    function updateCamera(){
      cam.x = clamp(localPlayer.x - cam.w/2, 0, MAP_W - cam.w);
      cam.y = clamp(localPlayer.y - cam.h/2, 0, MAP_H - cam.h);
    }

    function drawObject(o){
      const sx = o.x - cam.x, sy = o.y - cam.y;
      ctx.save();
      ctx.translate(sx, sy);
      ctx.rotate(o.angle);
      ctx.fillStyle = 'rgba(0,0,0,0.22)';
      ctx.beginPath(); ctx.ellipse(10, o.h*0.5 + 10, o.w*0.6, o.h*0.45, 0, 0, Math.PI*2); ctx.fill();
      const grad = ctx.createLinearGradient(-o.w/2, -o.h/2, o.w/2, o.h/2);
      grad.addColorStop(0, shade(o.color, -0.08)); grad.addColorStop(1, shade(o.color, 0.12));
      ctx.fillStyle = grad;
      ctx.lineWidth = 1.5;
      switch(o.type){
        case 'crate':
          ctx.fillRect(-o.w/2, -o.h/2, o.w, o.h);
          ctx.strokeStyle = shade(o.color, -0.25); ctx.strokeRect(-o.w/2, -o.h/2, o.w, o.h);
          break;
        case 'plant':
          ctx.fillStyle = '#6b4a2a'; ctx.fillRect(-o.w/8, o.h/8, o.w/4, o.h/4);
          ctx.fillStyle = o.color; ctx.beginPath(); ctx.ellipse(0, -o.h/8, o.w/3, o.h/3, 0, 0, Math.PI*2); ctx.fill();
          break;
        default:
          ctx.fillRect(-o.w/2, -o.h/2, o.w, o.h);
      }
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = 'rgba(255,255,255,0.03)';
      ctx.fillRect(-o.w/2, -o.h/2, o.w, o.h/3);
      ctx.globalCompositeOperation = 'source-over';
      ctx.restore();
    }

    function drawPlayer(p){
      const sx = Math.round(p.x - cam.x);
      const sy = Math.round(p.y - cam.y);
      ctx.save();
      const rad = ctx.createRadialGradient(sx, sy, 6, sx, sy, PLAYER_RADIUS*3);
      rad.addColorStop(0, 'rgba(255,255,255,0.06)');
      rad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = rad; ctx.beginPath(); ctx.arc(sx, sy, PLAYER_RADIUS*3, 0, Math.PI*2); ctx.fill();
      ctx.beginPath();
      const isCatcher = (members.room && members.room.catcher === p.uid) || (p.uid === members.room?.catcher);
      ctx.fillStyle = p.caught ? '#666' : (p.uid === members.room?.catcher ? '#ffd166' : '#4cc9f0');
      ctx.shadowColor = 'rgba(0,0,0,0.6)';
      ctx.shadowBlur = 12;
      ctx.arc(sx, sy, PLAYER_RADIUS, 0, Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#fff'; ctx.font = '14px system-ui,Arial'; ctx.textAlign = 'center';
      ctx.fillText(p.gameName || p.uid.slice(0,6), sx, sy - PLAYER_RADIUS - 10);
      if (p.transformed){
        ctx.fillStyle = 'rgba(255,255,255,0.12)'; ctx.beginPath(); ctx.arc(sx, sy, PLAYER_RADIUS+6, 0, Math.PI*2); ctx.fill();
      }
      if (p.caught){
        ctx.fillStyle = '#ff6b6b'; ctx.font = '12px system-ui,Arial'; ctx.fillText('CAUGHT', sx, sy + PLAYER_RADIUS + 14);
      }
      ctx.restore();
    }

    function drawPickup(pk){
      const sx = pk.x - cam.x, sy = pk.y - cam.y;
      ctx.save();
      ctx.beginPath();
      ctx.fillStyle = pk.color + '33';
      ctx.arc(sx, sy, 18, 0, Math.PI*2); ctx.fill();
      ctx.beginPath();
      ctx.fillStyle = pk.color;
      ctx.arc(sx, sy, pk.radius, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#021018'; ctx.font = '12px system-ui,Arial'; ctx.textAlign = 'center';
      const label = pk.type === 'speed' ? 'S' : (pk.type === 'invis' ? 'I' : 'D');
      ctx.fillText(label, sx, sy+4);
      ctx.restore();
    }

    function drawMiniMap(){
      const w = miniCanvas.width, h = miniCanvas.height;
      miniCtx.clearRect(0,0,w,h);
      miniCtx.fillStyle = '#041018'; miniCtx.fillRect(0,0,w,h);
      const sx = w / MAP_W, sy = h / MAP_H;
      for (const o of objects.slice(0,80)){
        miniCtx.fillStyle = shade(o.color, -0.06);
        miniCtx.fillRect(o.x * sx - 2, o.y * sy - 2, 4, 4);
      }
      for (const pk of pickups){
        miniCtx.fillStyle = pk.color;
        miniCtx.fillRect(pk.x * sx - 2, pk.y * sy - 2, 4, 4);
      }
      // minimap privacy: if local is seeker, hide others until main timer <= 60
      const seekerIsLocal = (members.room && members.room.catcher === local.uid);
      const mainRemain = gameEndAt ? Math.max(0, Math.ceil((gameEndAt - Date.now())/1000)) : MAIN_SECONDS;
      const showPlayers = !seekerIsLocal || mainRemain <= 60;
      for (const [uid, m] of Object.entries(members || {})){
        if (uid === 'room') continue;
        if (!showPlayers && uid !== local.uid) continue;
        miniCtx.beginPath();
        miniCtx.fillStyle = m.caught ? '#666' : (m.uid === members.room?.catcher ? '#ffd166' : '#4cc9f0');
        miniCtx.arc(m.x * sx, m.y * sy, 4, 0, Math.PI*2); miniCtx.fill();
      }
      miniCtx.strokeStyle = 'rgba(255,255,255,0.06)'; miniCtx.strokeRect(cam.x * sx, cam.y * sy, cam.w * sx, cam.h * sy);
    }

    /* -------------------------
       Game loop
       ------------------------- */
    let last = performance.now();
    function loop(now){
      const dt = Math.min(0.05, (now - last)/1000);
      last = now;

      // update localPlayer from DB cached members if present
      if (members[local.uid]) {
        const m = members[local.uid];
        localPlayer.x = m.x ?? localPlayer.x;
        localPlayer.y = m.y ?? localPlayer.y;
        localPlayer.caught = !!m.caught;
        localPlayer.transformed = !!m.transformed;
        localPlayer.transformTarget = m.transformTarget || null;
      }

      // local movement (if not caught and not freezeBlocked)
      if (!localPlayer.caught && !localPlayer.freezeBlocked){
        let mx=0,my=0;
        if (joy.active && (Math.abs(joy.x)>0.02 || Math.abs(joy.y)>0.02)){ mx = joy.x; my = joy.y; }
        else { if (keys['w']||keys['arrowup']) my -= 1; if (keys['s']||keys['arrowdown']) my += 1; if (keys['a']||keys['arrowleft']) mx -= 1; if (keys['d']||keys['arrowright']) mx += 1; }
        const len = Math.hypot(mx,my);
        const speedMult = (localPlayer.speedUntil && Date.now() < localPlayer.speedUntil) ? 1.35 : 1;
        if (len > 0.01){
          localPlayer.vx = (mx/len) * localPlayer.speed * speedMult;
          localPlayer.vy = (my/len) * localPlayer.speed * speedMult;
        } else { localPlayer.vx = 0; localPlayer.vy = 0; }
        localPlayer.x += localPlayer.vx * dt;
        localPlayer.y += localPlayer.vy * dt;
        localPlayer.x = clamp(localPlayer.x, PLAYER_RADIUS, MAP_W-PLAYER_RADIUS);
        localPlayer.y = clamp(localPlayer.y, PLAYER_RADIUS, MAP_H-PLAYER_RADIUS);
        writeLocalPlayer();
      }

      // update bots from DB entries (they are updated by bot controller)
      // update camera, particles, catches, render
      updateCamera();
      updateParticlesLocal(dt);
      render();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    function updateParticlesLocal(dt){
      for (let i=particlesLocal.length-1;i>=0;i--){
        const p = particlesLocal[i];
        p.life -= dt;
        if (p.life <= 0) particlesLocal.splice(i,1);
        else { p.x += p.vx * dt; p.y += p.vy * dt; p.vy += 420 * dt; }
      }
    }

    function render(){
      ctx.fillStyle = '#071018'; ctx.fillRect(0,0,INTERNAL_W,INTERNAL_H);
      const g = ctx.createLinearGradient(0,0,0,INTERNAL_H); g.addColorStop(0,'#071018'); g.addColorStop(1,'#020305'); ctx.fillStyle = g; ctx.fillRect(0,0,INTERNAL_W,INTERNAL_H);
      ctx.strokeStyle = 'rgba(255,255,255,0.02)'; ctx.lineWidth = 1;
      const tile = 128;
      for (let x = - (cam.x % tile); x < INTERNAL_W; x += tile){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,INTERNAL_H); ctx.stroke(); }
      for (let y = - (cam.y % tile); y < INTERNAL_H; y += tile){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(INTERNAL_W,y); ctx.stroke(); }

      for (const w of walls){
        ctx.fillStyle = '#1f2226'; ctx.fillRect(w.x - cam.x, w.y - cam.y, w.w, w.h);
        ctx.strokeStyle = '#0f1112'; ctx.lineWidth = 2; ctx.strokeRect(w.x - cam.x, w.y - cam.y, w.w, w.h);
      }

      const drawList = objects.slice().sort((a,b)=>a.y-b.y);
      for (const o of drawList) drawObject(o);
      for (const pk of pickups) drawPickup(pk);
      for (const p of particlesLocal){ ctx.globalAlpha = Math.max(0,p.life); ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x - cam.x, p.y - cam.y, p.size, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1; }

      // draw members from DB
      const list = Object.entries(members).filter(([k]) => k !== 'room').map(([k,v]) => v).sort((a,b)=> (a.y||0)-(b.y||0));
      for (const m of list) drawPlayer(m);

      drawMiniMap();
    }

    /* -------------------------
       Waiting / start logic (DB-driven)
       ------------------------- */
    let phase = 'waiting';
    let countdownStart = 0;
    let freezeUntil = 0;
    let gameEndAt = 0;
    const COUNTDOWN3 = 3;
    const FREEZE_SECONDS = 30;
    const MAIN_SECONDS = 10*60;
    let tickHandle = null;

    function updateWaitingUI(){
      const total = Object.values(members).filter(m => m && !m.isBot).length || 1;
      const ready = Object.values(members).filter(m => m && m.ready).length || 0;
      readyCountEl.textContent = `${ready}/${total}`;
      waitingFill.style.width = `${Math.round((ready/total)*100)}%`;
      if (ready > 0 && ready === total) {
        if (updateWaitingUI._deb) clearTimeout(updateWaitingUI._deb);
        updateWaitingUI._deb = setTimeout(()=>{ checkAllReadyAndStart(); updateWaitingUI._deb = null; }, 80);
      }
    }

    async function checkAllReadyAndStart(){
      if (!roomRef) return;
      const roomSnap = await get(roomRef);
      const roomData = roomSnap.exists() ? roomSnap.val() : {};
      if (roomData.phase && roomData.phase !== 'waiting') return; // already started
      const total = Object.values(members).filter(m => m && !m.isBot).length || 1;
      const ready = Object.values(members).filter(m => m && m.ready).length || 0;
      if (ready !== total) return;
      // set phase in DB so everyone starts
      const now = Date.now();
      await update(roomRef, { phase: 'countdown3', countdownStart: now });
      // local update
      phase = 'countdown3';
      countdownStart = now;
      waitingBar.style.display = 'none';
      startTick();
    }

    function startTick(){
      if (tickHandle) clearInterval(tickHandle);
      tickHandle = setInterval(async ()=>{
        // read room
        if (!roomRef) return;
        const snap = await get(roomRef);
        if (!snap.exists()) return;
        const data = snap.val();
        const dbPhase = data.phase || 'waiting';
        if (dbPhase === 'countdown3'){
          const startAt = data.countdownStart || Date.now();
          const elapsed = Math.floor((Date.now() - startAt)/1000);
          const remain = Math.max(0, COUNTDOWN3 - elapsed);
          phaseText.textContent = `Starting in ${remain}s`;
          if (remain <= 0){
            // choose catcher in DB
            await runTransaction(roomRef, (cur) => {
              if (!cur) return cur;
              if (cur.phase && cur.phase !== 'countdown3') return cur;
              // pick random member uid
              const mem = cur.members || {};
              const uids = Object.keys(mem || {}).filter(k => mem[k] && !mem[k].isBot);
              if (uids.length === 0) uids.push(Object.keys(mem || {})[0]);
              const pick = uids[Math.floor(Math.random()*uids.length)];
              return { ...cur, phase: 'freeze30', freezeUntil: Date.now() + FREEZE_SECONDS*1000, catcher: pick };
            });
          }
        } else if (dbPhase === 'freeze30'){
          const remain = Math.max(0, Math.ceil((data.freezeUntil || Date.now())/1000 - Date.now()/1000));
          freezeTimerEl.textContent = String(remain);
          overlayBigTimer.textContent = String(remain);
          // show overlay only to local if local is catcher
          if (data.catcher === local.uid) blackOverlay.style.display = 'flex';
          else blackOverlay.style.display = 'none';
          if (remain <= 0){
            // transition to running
            await update(roomRef, { phase: 'running', gameEndAt: Date.now() + MAIN_SECONDS*1000, gameStartAt: Date.now() });
          }
        } else if (dbPhase === 'running'){
          const remain = Math.max(0, Math.ceil((data.gameEndAt || Date.now())/1000 - Date.now()/1000));
          mainTimerEl.textContent = fmtTime(remain);
          if (remain <= 0 && !data.finished){
            // compute winner and set finished
            const memSnap = await get(membersRef);
            const mem = memSnap.exists() ? memSnap.val() : {};
            const uncaught = Object.keys(mem).filter(k => mem[k] && !mem[k].caught);
            const winner = uncaught.length ? uncaught[Math.floor(Math.random()*uncaught.length)] : data.catcher;
            await update(roomRef, { finished: true, winnerUid: winner, finishedAt: Date.now() });
          }
        } else if (dbPhase === 'finished'){
          // show end screen
          const winnerUid = data.winnerUid;
          let winnerName = '—';
          if (winnerUid && members[winnerUid]) winnerName = members[winnerUid].gameName || winnerUid.slice(0,6);
          document.getElementById('winnerName').textContent = winnerName;
          document.getElementById('endScreen').style.display = 'flex';
          clearInterval(tickHandle);
        }
      }, 400);
    }

    /* -------------------------
       Helpers: write local player to DB
       ------------------------- */
    let lastWrite = 0;
    async function writeLocalPlayer(){
      if (!roomCode || !local.uid) return;
      const now = Date.now();
      if (now - lastWrite < 200) return;
      lastWrite = now;
      try {
        await update(ref(db, `rooms/${roomCode}/members/${local.uid}`), {
          x: localPlayer.x,
          y: localPlayer.y,
          caught: !!localPlayer.caught,
          transformed: !!localPlayer.transformed,
          transformTarget: localPlayer.transformTarget || null,
          ready: true
        });
      } catch (e) { console.error(e); }
    }

    /* -------------------------
       Auth & join flow
       - when user arrives from custom.html, they are redirected here with ?room=CODE
       - if no room param, we try to find a room where they are a member
       - if single human in room, a bot member is created in DB and a local bot controller runs
       ------------------------- */
    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        // if not signed in, redirect to index/login
        window.location.href = 'index.html';
        return;
      }
      local.uid = user.uid;
      local.gameName = (user.email ? user.email.split('@')[0] : user.uid.slice(0,6));
      youNameEl.textContent = local.gameName;
      // determine room
      let code = getRoomFromQuery();
      if (!code) code = await findRoomForUser(local.uid);
      if (!code) {
        // no room found -> redirect back to custom
        window.location.href = 'custom.html';
        return;
      }
      // join
      await joinRoomAndSync(code);

      // ensure we have members snapshot and room metadata
      const roomSnap = await get(roomRef);
      if (!roomSnap.exists()) {
        // create room if missing
        await set(roomRef, { createdAt: Date.now(), owner: local.uid, phase: 'waiting' });
      }
      // ensure local DB member exists (done in joinRoomAndSync)
      // attach members listener already set in joinRoomAndSync
    });

    /* -------------------------
       UI interactions
       ------------------------- */
    document.getElementById('phaseText').addEventListener('click', async () => {
      // toggle ready
      localPlayer.ready = true;
      await writeLocalPlayer();
      updateWaitingUI();
      checkAllReadyAndStart();
    });
    document.getElementById('homeBtn').addEventListener('click', ()=> window.location.href = 'custom.html');

    /* -------------------------
       Initial local placement & auto-ready fallback
       ------------------------- */
    localPlayer.x = MAP_W/2;
    localPlayer.y = MAP_H/2;

    // auto-ready local after 6s if not pressed
    setTimeout(async ()=>{
      if (!localPlayer.ready && local.uid) {
        localPlayer.ready = true;
        await writeLocalPlayer();
        updateWaitingUI();
        checkAllReadyAndStart();
      }
    }, 6000);

    /* -------------------------
       Clean up on unload
       ------------------------- */
    window.addEventListener('beforeunload', async () => {
      if (roomCode && local.uid) {
        try { await set(ref(db, `rooms/${roomCode}/members/${local.uid}`), null); } catch(e) {}
      }
    });

    /* -------------------------
       Expose debug helpers
       ------------------------- */
    window._local = localPlayer;
    window._members = members;
    window._roomCode = () => roomCode;
  </script>
</body>
  </html>
